#!/usr/bin/env ruby
# encoding: UTF-8
# frozen_string_literal: true

require 'bundler/setup'

require 'image_optim'

README_FILE = File.expand_path('../../README.markdown', __FILE__)
BEGIN_MARKER = '<!---<worker-options>-->'
END_MARKER = '<!---</worker-options>-->'

def write_worker_options(io, klass)
  io.puts "### #{klass.bin_sym}:"
  if klass.option_definitions.empty?
    io.puts 'Worker has no options'
  else
    klass.option_definitions.each do |option_definition|
      line = "* `:#{option_definition.name}` â€” #{option_definition.description}"
      unless line['(defaults']
        line += " *(defaults to #{option_definition.default_description})*"
      end
      io.puts line
    end
  end
  io.puts
end

def write_marked(io)
  io.puts BEGIN_MARKER
  io.puts '<!-- markdown for worker options is generated by ' \
          "`#{Pathname($PROGRAM_NAME).cleanpath}` -->"
  io.puts

  ImageOptim::Worker.klasses.sort_by(&:name).each do |klass|
    write_worker_options(io, klass)
  end

  io.puts END_MARKER
end

def update_readme(text)
  marked_reg = /#{Regexp.escape(BEGIN_MARKER)}.*#{Regexp.escape(END_MARKER)}/m
  text.clone.sub!(marked_reg) do
    StringIO.open do |io|
      write_marked(io)

      io.string.strip
    end
  end
end

readme = File.read(README_FILE)
program_name = File.basename($PROGRAM_NAME, '.*')
case ARGV
when []
  if (readme = update_readme(readme))
    File.write(README_FILE, readme)
  else
    abort 'Did not update worker options'
  end
when %w[-n]
  updated = update_readme(readme)
  unless updated == readme
    puts "Run #{program_name} to update work options in readme"
    IO.popen('diff -u README.markdown -', 'w'){ |f| f << updated }
    exit 1
  end
else
  abort "#{program_name} [-n] (-n to change exit code instead of updating)"
end
